"""Validation report renderer (publishable PDF).

This module renders a human-readable PDF from `validation_report.json`
produced by `nextstat validation-report`.

Design goal: an audit-friendly document that is dependency-light
(matplotlib only, via `nextstat[viz]`).
"""

from __future__ import annotations

import argparse
import datetime
import json
from dataclasses import dataclass
from pathlib import Path
from typing import Any, Mapping


def _require_matplotlib():
    try:
        import matplotlib  # noqa: F401
    except Exception as e:  # pragma: no cover
        raise ImportError(
            "Missing dependency: matplotlib. Install via `pip install nextstat[viz]`."
        ) from e


def _apply_pub_style():
    import matplotlib as mpl

    mpl.use("Agg", force=True)
    mpl.rcParams.update(
        {
            "figure.constrained_layout.use": True,
            "savefig.bbox": "tight",
            "axes.grid": False,
            "axes.spines.top": False,
            "axes.spines.right": False,
            "axes.spines.left": False,
            "axes.spines.bottom": False,
            "font.size": 10.0,
            # Keep text as text in SVG, and embed fonts in PDF.
            "svg.fonttype": "none",
            "pdf.fonttype": 42,
            "ps.fonttype": 42,
        }
    )


def _read_json(path: Path) -> dict[str, Any]:
    return json.loads(path.read_text())


def _sha_short(s: str | None, n: int = 12) -> str:
    if not s:
        return "unknown"
    s = str(s)
    return s[:n]


@dataclass(frozen=True)
class _Targets:
    pdf: Path


def _new_page(figsize: tuple[float, float] = (8.27, 11.69)):
    import matplotlib.pyplot as plt

    fig = plt.figure(figsize=figsize)
    ax = fig.add_subplot(111)
    ax.axis("off")
    return fig, ax


def _add_title(ax, title: str, subtitle: str | None = None):
    ax.text(0.0, 0.97, title, ha="left", va="top", fontsize=18, weight="bold", transform=ax.transAxes)
    if subtitle:
        ax.text(0.0, 0.93, subtitle, ha="left", va="top", fontsize=11, color="#374151", transform=ax.transAxes)


def _add_kv_block(ax, y0: float, kv: list[tuple[str, str]]):
    y = y0
    for k, v in kv:
        ax.text(0.0, y, f"{k}:", ha="left", va="top", family="monospace", transform=ax.transAxes)
        ax.text(0.28, y, v, ha="left", va="top", family="monospace", transform=ax.transAxes)
        y -= 0.032


def _render_pdf(report: Mapping[str, Any], targets: _Targets):
    _require_matplotlib()
    _apply_pub_style()

    from matplotlib.backends.backend_pdf import PdfPages

    schema_version = str(report.get("schema_version") or "")
    overall = str(((report.get("apex2_summary") or {}).get("overall")) or "unknown")
    det = bool(report.get("deterministic") is True)

    ds = report.get("dataset_fingerprint") or {}
    env = report.get("environment") or {}
    apex = report.get("apex2_summary") or {}
    suites = apex.get("suites") or {}

    ws_sha = _sha_short(ds.get("workspace_sha256"))
    apex_sha = _sha_short(apex.get("master_report_sha256"))

    targets.pdf.parent.mkdir(parents=True, exist_ok=True)
    # Matplotlib writes timestamps into PDF metadata by default. In deterministic mode,
    # pin CreationDate/ModDate so the output is stable across runs.
    metadata: dict[str, Any] | None = None
    if det:
        fixed_dt = datetime.datetime(1970, 1, 1, 0, 0, 0, tzinfo=datetime.timezone.utc)
        metadata = {
            "Title": "NextStat Validation Report",
            "Creator": "nextstat.validation_report",
            "Producer": "NextStat (matplotlib)",
            "CreationDate": fixed_dt,
            "ModDate": fixed_dt,
        }

    with PdfPages(targets.pdf, metadata=metadata) as pages:
        # Cover
        fig, ax = _new_page()
        _add_title(
            ax,
            "NextStat Validation Report",
            subtitle=f"schema={schema_version}  overall={overall}  deterministic={det}",
        )
        _add_kv_block(
            ax,
            0.86,
            [
                ("workspace_sha256", ws_sha),
                ("apex2_master_sha256", apex_sha),
                ("nextstat_version", str(env.get("nextstat_version") or "unknown")),
                ("python_version", str(env.get("python_version") or "unknown")),
                ("platform", str(env.get("platform") or "unknown")),
            ],
        )
        ax.text(
            0.0,
            0.08,
            "Generated by `nextstat validation-report` (OSS baseline).",
            ha="left",
            va="bottom",
            fontsize=9,
            color="#6B7280",
            transform=ax.transAxes,
        )
        pages.savefig(fig)

        # Dataset fingerprint
        fig, ax = _new_page()
        _add_title(ax, "Dataset Fingerprint")
        channels = ds.get("channels") or []
        n_bins = ds.get("n_bins_per_channel") or []
        obs = ds.get("observation_summary") or {}
        _add_kv_block(
            ax,
            0.88,
            [
                ("workspace_sha256", str(ds.get("workspace_sha256") or "unknown")),
                ("workspace_bytes", str(ds.get("workspace_bytes") or "unknown")),
                ("n_channels", str(ds.get("n_channels") or len(channels))),
                ("channels", ", ".join(map(str, channels)) if channels else "unknown"),
                ("n_bins_per_channel", ", ".join(map(str, n_bins)) if n_bins else "unknown"),
                ("n_samples_total", str(ds.get("n_samples_total") or "unknown")),
                ("n_parameters", str(ds.get("n_parameters") or "unknown")),
                ("obs_total", str(obs.get("total_observed") or "unknown")),
                ("obs_min_bin", str(obs.get("min_bin") or "unknown")),
                ("obs_max_bin", str(obs.get("max_bin") or "unknown")),
            ],
        )
        pages.savefig(fig)

        # Apex2 summary
        fig, ax = _new_page()
        _add_title(ax, "Apex2 Summary")
        ax.text(
            0.0,
            0.88,
            f"master_report_sha256: {str(apex.get('master_report_sha256') or 'unknown')}",
            ha="left",
            va="top",
            family="monospace",
            transform=ax.transAxes,
        )

        # Render a small fixed-width table.
        rows: list[str] = []
        rows.append(f"{'suite':<22} {'status':<8} {'cases':>6} {'ok':>6} {'worst|dNLL|':>12}")
        rows.append("-" * 60)
        for name in sorted(map(str, suites.keys())):
            s = suites.get(name) or {}
            status = str(s.get("status") or "unknown")
            n_cases = s.get("n_cases")
            n_ok = s.get("n_ok")
            worst = s.get("worst_delta_nll")
            worst_str = (
                f"{float(worst):.3e}" if isinstance(worst, (int, float)) else "-"
            )
            rows.append(
                f"{name:<22} {status:<8} {str(n_cases) if n_cases is not None else '-':>6} "
                f"{str(n_ok) if n_ok is not None else '-':>6} "
                f"{worst_str:>12}"
            )
        table = "\n".join(rows)
        ax.text(0.0, 0.82, table, ha="left", va="top", family="monospace", transform=ax.transAxes)
        pages.savefig(fig)

        # Environment
        fig, ax = _new_page()
        _add_title(ax, "Environment")
        det_settings = env.get("determinism_settings") or {}
        _add_kv_block(
            ax,
            0.88,
            [
                ("nextstat_version", str(env.get("nextstat_version") or "unknown")),
                ("nextstat_git_commit", str(env.get("nextstat_git_commit") or "unknown")),
                ("rust_toolchain", str(env.get("rust_toolchain") or "unknown")),
                ("python_version", str(env.get("python_version") or "unknown")),
                ("pyhf_version", str(env.get("pyhf_version") or "unknown")),
                ("platform", str(env.get("platform") or "unknown")),
                ("determinism_settings", json.dumps(det_settings, sort_keys=True)),
            ],
        )
        pages.savefig(fig)


def main(argv: list[str] | None = None) -> int:
    ap = argparse.ArgumentParser(prog="python -m nextstat.validation_report")
    sub = ap.add_subparsers(dest="cmd", required=True)

    ap_render = sub.add_parser("render", help="Render validation_report.json to a PDF.")
    ap_render.add_argument("--input", type=Path, required=True, help="Path to validation_report.json")
    ap_render.add_argument("--pdf", type=Path, required=True, help="Output PDF path")

    args = ap.parse_args(argv)

    if args.cmd == "render":
        report = _read_json(args.input)
        _render_pdf(report, _Targets(pdf=args.pdf))
        return 0

    raise SystemExit("unreachable")  # pragma: no cover


if __name__ == "__main__":  # pragma: no cover
    raise SystemExit(main())
