#!/usr/bin/env python3
"""
Generate external ordinal goldens using PyMC (optional dependency).

This script reads a NextStat ordinal fixture (generated by
`tests/generate_golden_ordinal.py`) and fits an equivalent ordered model in PyMC
via MAP. It then writes a JSON blob suitable for merging via:

  python3 tests/external/merge_ordinal_external_goldens.py <fixture.json> <external.json>

Usage:
  python3 tests/external/generate_ordinal_goldens_pymc.py \
    tests/fixtures/ordinal/ordered_logit_small.json \
    --seed 123 \
    --out /tmp/external_ordinal_logit.json
"""

from __future__ import annotations

import argparse
import json
import math
import sys
from pathlib import Path
from typing import Any, List, Sequence


def _softplus(x: float) -> float:
    if x > 0.0:
        return x + math.log1p(math.exp(-x))
    return math.log1p(math.exp(x))


def _log_sigmoid(x: float) -> float:
    return -_softplus(-x)


def _Phi(x: float) -> float:
    return 0.5 * math.erfc(-float(x) / math.sqrt(2.0))


def _logdiffexp(a: float, b: float) -> float:
    if not (a > b):
        raise ValueError("logdiffexp requires a>b")
    return float(a + math.log1p(-math.exp(float(b - a))))


def _ordered_logit_logp(*, eta: float, cutpoints: Sequence[float], y: int) -> float:
    k = len(cutpoints) + 1
    if y == 0:
        return _log_sigmoid(float(cutpoints[0]) - eta)
    if y == k - 1:
        return _log_sigmoid(eta - float(cutpoints[-1]))
    a = float(cutpoints[y]) - eta
    b = float(cutpoints[y - 1]) - eta
    la = _log_sigmoid(a)
    lb = _log_sigmoid(b)
    return _logdiffexp(la, lb)


def _ordered_probit_logp(*, eta: float, cutpoints: Sequence[float], y: int) -> float:
    k = len(cutpoints) + 1
    if y == 0:
        p = _Phi(float(cutpoints[0]) - eta)
    elif y == k - 1:
        p = 1.0 - _Phi(float(cutpoints[-1]) - eta)
    else:
        p = _Phi(float(cutpoints[y]) - eta) - _Phi(float(cutpoints[y - 1]) - eta)
    p = max(float(p), 1e-300)
    return float(math.log(p))


def _sigmoid(x: float) -> float:
    if x >= 0.0:
        z = math.exp(-x)
        return 1.0 / (1.0 + z)
    z = math.exp(x)
    return z / (1.0 + z)


def _predict_proba(*, link: str, coef: Sequence[float], cutpoints: Sequence[float], x: Sequence[Sequence[float]]):
    out: List[List[float]] = []
    for row in x:
        eta = sum(float(a) * float(b) for a, b in zip(row, coef))
        if link == "logit":
            cdf = [_sigmoid(float(cutpoints[0]) - eta)]
            for ck in cutpoints[1:]:
                cdf.append(_sigmoid(float(ck) - eta))
        elif link == "probit":
            cdf = [_Phi(float(cutpoints[0]) - eta)]
            for ck in cutpoints[1:]:
                cdf.append(_Phi(float(ck) - eta))
        else:
            raise ValueError("unknown link")

        probs: List[float] = [float(cdf[0])]
        for j in range(1, len(cdf)):
            probs.append(float(cdf[j] - cdf[j - 1]))
        probs.append(float(1.0 - cdf[-1]))
        probs = [0.0 if p < 0.0 and p > -1e-12 else float(p) for p in probs]
        s = sum(probs)
        probs = [p / s for p in probs]
        out.append(probs)
    return out


def main(argv: list[str]) -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("fixture", type=Path, help="Path to tests/fixtures/ordinal/*.json")
    ap.add_argument("--seed", type=int, default=123, help="RNG seed for PyMC init (default: 123)")
    ap.add_argument("--out", type=Path, required=True, help="Output JSON path")
    ap.add_argument("--maxiter", type=int, default=5000, help="MAP optimizer iterations (default: 5000)")
    args = ap.parse_args(argv[1:])

    fx = json.loads(args.fixture.read_text())
    if fx.get("kind") != "ordinal_ordered":
        print("fixture kind must be 'ordinal_ordered'", file=sys.stderr)
        return 2

    link = fx.get("link")
    if link not in ("logit", "probit"):
        print("fixture link must be 'logit' or 'probit'", file=sys.stderr)
        return 2

    x = fx["x"]
    y = fx["y"]
    n_levels = int(fx["n_levels"])
    grid_x = fx["grid_x"]

    try:
        import numpy as np  # type: ignore
        import pymc as pm  # type: ignore
        import pytensor.tensor as pt  # type: ignore
    except Exception as e:  # pragma: no cover
        print(
            "Missing optional dependency for PyMC goldens. Install:\n"
            "  pip install \"pymc>=5\" \"pytensor\" \"numpy>=2\"",
            file=sys.stderr,
        )
        raise SystemExit(2) from e

    X = np.asarray(x, dtype=float)
    Y = np.asarray(y, dtype=int)
    if X.ndim != 2 or Y.ndim != 1:
        raise SystemExit("invalid fixture shapes")
    if Y.min() < 0 or Y.max() >= n_levels:
        raise SystemExit("y out of range for n_levels")

    p = int(X.shape[1])
    k = int(n_levels)

    with pm.Model() as m:
        beta = pm.Normal("beta", mu=0.0, sigma=2.0, shape=(p,))

        cut0 = pm.Normal("cut0", mu=0.0, sigma=2.0)
        if k == 2:
            cutpoints = pt.stack([cut0])
        else:
            deltas = pm.HalfNormal("deltas", sigma=1.0, shape=(k - 2,))
            cutpoints = pt.concatenate([pt.stack([cut0]), cut0 + pt.cumsum(deltas)])

        eta = pt.dot(X, beta)
        eta2 = eta[:, None]
        cuts2 = cutpoints[None, :]

        if link == "logit":
            cdf = pm.math.sigmoid(cuts2 - eta2)
        else:
            # Standard Normal CDF via erf.
            cdf = 0.5 * (1.0 + pt.erf((cuts2 - eta2) / math.sqrt(2.0)))

        p0 = cdf[:, 0:1]
        pmid = cdf[:, 1:] - cdf[:, :-1]
        plast = 1.0 - cdf[:, -1:]
        probs = pt.concatenate([p0, pmid, plast], axis=1)

        pm.Categorical("y", p=probs, observed=Y)

        mp = pm.find_MAP(
            method="L-BFGS-B",
            maxeval=int(args.maxiter),
            return_raw=True,
            random_seed=int(args.seed),
        )

    beta_hat = [float(v) for v in mp["beta"]]
    cut0_hat = float(mp["cut0"])
    if k == 2:
        cut_hat = [cut0_hat]
    else:
        deltas_hat = [float(v) for v in mp["deltas"]]
        cut_hat = [cut0_hat]
        acc = cut0_hat
        for d in deltas_hat:
            acc += max(float(d), 0.0)
            cut_hat.append(float(acc))

    # Compute NLL at MAP via deterministic pure-Python objective.
    nll = 0.0
    for row, yi in zip(x, y):
        eta_i = sum(float(a) * float(b) for a, b in zip(row, beta_hat))
        if link == "logit":
            lp = _ordered_logit_logp(eta=eta_i, cutpoints=cut_hat, y=int(yi))
        else:
            lp = _ordered_probit_logp(eta=eta_i, cutpoints=cut_hat, y=int(yi))
        nll -= float(lp)

    out: dict[str, Any] = {
        "tool": "pymc",
        "tool_version": getattr(pm, "__version__", None),
        "link": link,
        "seed": int(args.seed),
        "method": "find_MAP",
        "coef": beta_hat,
        "cutpoints": cut_hat,
        "nll_at_hat": float(nll),
        "grid_pred_proba": _predict_proba(link=link, coef=beta_hat, cutpoints=cut_hat, x=grid_x),
    }

    args.out.write_text(json.dumps(out, indent=2, sort_keys=True) + "\n")
    print(f"wrote {args.out}")
    return 0


if __name__ == "__main__":
    raise SystemExit(main(sys.argv))

